<!doctype html>
<html>
  <head>
    <meta charset = "utf-8">
    <title>崴寶</title>
    <link rel="icon" href="IMG_7558.PNG">
  </head>
  <body>
      hello world
  </body>
</html>
<!DOCTYPE html>
<html>
<head>
    <title>軟糬女孩</title>
    <style>
        body { margin: 0; background: #f0e8d9; overflow: hidden; font-family: Arial; }
        canvas { display: block; cursor: none; }
        #info { position: absolute; top: 10px; left: 10px; color: #666; font-size: 14px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">滑鼠控制眼睛 • 點擊戳她 • 拖拉拉扯 • 她會自動回復</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // 粒子系統 (臉部約 20x20 網格)
        class Particle {
            constructor(x, y) {
                this.originalX = x;
                this.originalY = y;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.pin = false;
            }
            update() {
                if (!this.pin) {
                    this.vx *= 0.9; // 阻尼
                    this.vy *= 0.9;
                    this.x += this.vx;
                    this.y += this.vy;
                    // 回復力 (超軟糬效果)
                    const dx = this.originalX - this.x;
                    const dy = this.originalY - this.y;
                    this.vx += dx * 0.05;
                    this.vy += dy * 0.05;
                }
            }
        }

        // 建立臉部粒子網格 (中心位置)
        const particles = [];
        const cols = 25, rows = 25;
        const faceW = 300, faceH = 400;
        const cx = canvas.width / 2, cy = canvas.height / 2;
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                const px = cx + (x - cols/2) * (faceW/cols) * 0.8;
                const py = cy + (y - rows/2) * (faceH/rows) * 1.2;
                // 臉型：邊緣向內收
                const faceX = (x/cols - 0.5) * (1 - Math.pow(y/rows - 0.5, 2) * 0.3);
                const faceY = (y/rows - 0.5) * (1 + Math.abs(x/cols - 0.5) * 0.2);
                particles.push(new Particle(px + faceX * 50, py + faceY * 40));
            }
        }

        // 滑鼠互動
        let mouseX = 0, mouseY = 0, isDragging = false, mousePressed = false;
        canvas.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        canvas.addEventListener('mousedown', () => { mousePressed = true; });
        canvas.addEventListener('mouseup', () => { mousePressed = false; isDragging = false; });
        canvas.addEventListener('mouseleave', () => { mousePressed = false; });

        // 繪製函數
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 更新所有粒子
            particles.forEach(p => p.update());

            // 滑鼠戳/拖互動 (最近粒子)
            let closest = particles[0];
            let minDist = 999;
            particles.forEach(p => {
                const dist = Math.hypot(p.x - mouseX, p.y - mouseY);
                if (dist < minDist && dist < 80) {
                    minDist = dist;
                    closest = p;
                }
            });

            if (mousePressed) {
                closest.pin = true;
                closest.x = mouseX;
                closest.y = mouseY;
                isDragging = true;
                // 戳擊波紋效果
                particles.forEach(p => {
                    const dist = Math.hypot(p.x - mouseX, p.y - mouseY);
                    if (dist < 100) {
                        p.vx += (mouseX - p.x) * 0.3 / dist;
                        p.vy += (mouseY - p.y) * 0.3 / dist;
                    }
                });
            } else {
                closest.pin = false;
            }

            // 繪製臉部 (漸變半透明網格)
            ctx.save();
            ctx.strokeStyle = 'rgba(255,220,180,0.8)';
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.shadowColor = '#ffcc99';
            ctx.shadowBlur = 20;
            for (let y = 0; y < rows - 1; y++) {
                for (let x = 0; x < cols - 1; x++) {
                    const p1 = particles[y * cols + x];
                    const p2 = particles[y * cols + x + 1];
                    const p3 = particles[(y + 1) * cols + x];
                    const p4 = particles[(y + 1) * cols + x + 1];
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(p4.x, p4.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.closePath();
                    ctx.stroke();
                }
            }
            ctx.restore();

            // 繪製眼睛 (隨滑鼠移動)
            const eyeSize = 25;
            const eyeLX = cx - 60 + (mouseX - cx) * 0.3;
            const eyeLY = cy - 50 + (mouseY - cy) * 0.3;
            const eyeRX = cx + 40 + (mouseX - cx) * 0.3;
            const eyeRY = cy - 50 + (mouseY - cy) * 0.3;
            
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#000';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(eyeLX, eyeLY, eyeSize, 0, Math.PI * 2);
            ctx.arc(eyeRX, eyeRY, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#333';
            ctx.shadowBlur = 0;
            const pupilLX = eyeLX + (mouseX - eyeLX) * 0.4;
            const pupilLY = eyeLY + (mouseY - eyeLY) * 0.4;
            const pupilRX = eyeRX + (mouseX - eyeRX) * 0.4;
            const pupilRY = eyeRY + (mouseY - eyeRY) * 0.4;
            ctx.beginPath();
            ctx.arc(pupilLX, pupilLY, 12, 0, Math.PI * 2);
            ctx.arc(pupilRX, pupilRY, 12, 0, Math.PI * 2);
            ctx.fill();

            // 滑鼠提示
            if (isDragging) {
                ctx.fillStyle = 'rgba(255,100,100,0.3)';
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 15, 0, Math.PI * 2);
                ctx.fill();
            }

            requestAnimationFrame(draw);
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        draw();
    </script>
</body>
</html>
